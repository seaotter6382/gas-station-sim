<html>
    <head>
        <style>
            #userPlayer { height: 50px; width: 50px; background-color: blue; position: absolute; z-index: 1; border-radius: 2px; }
            .font { font-family: "monospace", sans-serif; }
        </style>
    </head>
    <body>
        <div id="userPlayer"></div>
        <script type="module">
            import { getKeybinds } from "./fetchKeybinds.js";
            import { createProx } from "./prox.js";
            let keybinds = await getKeybinds();
            console.log(keybinds);
            let keys = {};
            let prox = [];
            let pos = {x: window.innerWidth / 2 - 25, y: window.innerHeight / 2 - 25};
            let speed = 2;
            let mainPlayer = document.getElementById("userPlayer");
            mainPlayer.style.width = "50px";
            mainPlayer.style.height = "50px";
            document.addEventListener("keydown", (event) => {
                keys[event.key] = true;
            });
            document.addEventListener("keyup", (event) => {
                delete keys[event.key];
            });
            function renderProx() {
                prox.forEach(p => {
                    if (!document.getElementById(p.id)) {
                        document.body.appendChild(p);
                    } else {
                        const proxCenterX = parseFloat(p.style.left) + parseFloat(p.style.width) / 2;
                        const proxCenterY = parseFloat(p.style.top) + parseFloat(p.style.height) / 2;
                        const playerCenterX = pos.x + parseFloat(mainPlayer.style.width) / 2;
                        const playerCenterY = pos.y + parseFloat(mainPlayer.style.height) / 2;
                        const distance = Math.sqrt(Math.pow(proxCenterX - playerCenterX, 2) + Math.pow(proxCenterY - playerCenterY, 2));
                        console.log(distance);
                        if (distance > 200) {
                            p.style.opacity = 0;
                        } else {
                            p.style.opacity = 1;
                        }
                    }
                });
            }
            let pTime = 0;
            const f = 200;
            let size = 0;
            function gameLoop(currentTime) {
                let deltaTime = (currentTime - pTime) / 1000;
                pTime = currentTime;
                const e = f * deltaTime;
                if (keys[keybinds['forward']]) pos.y -= e;
                if (keys[keybinds['backward']]) pos.y += e;
                if (keys[keybinds['right']]) pos.x += e;
                if (keys[keybinds['left']]) pos.x -= e;
                if (keys[keybinds['use']]) {
                    console.log("pressed");
                    let closestProx = null;
                    let closestDistance = Infinity;
                    prox.forEach(p => {
                        const proxCenterX = parseFloat(p.style.left) + parseFloat(p.style.width) / 2;
                        const proxCenterY = parseFloat(p.style.top) + parseFloat(p.style.height) / 2;
                        const playerCenterX = pos.x + parseFloat(mainPlayer.style.width) / 2;
                        const playerCenterY = pos.y + parseFloat(mainPlayer.style.height) / 2;
                        const distance = Math.sqrt(Math.pow(proxCenterX - playerCenterX, 2) + Math.pow(proxCenterY - playerCenterY, 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestProx = p;
                        }
                    });
                    if (closestProx) {
                        console.log(closestProx);
                        closestProx.querySelector("#miniCircle").style.transform = "scale(" + size + ")";
                        size += e / 50;
                        if (size > 5) {
                            prox = prox.filter(p => p !== closestProx);
                            if (closestProx.parentNode) {
                                closestProx.parentNode.removeChild(closestProx);
                            }
                        }
                    }
                } else {
                    size = 0;
                    prox.forEach(p => {
                        if (p.querySelector("#miniCircle")) {
                            p.querySelector("#miniCircle").style.transform = "scale(0)";
                        }
                    });
                }
                if (keys[keybinds['use2']]) {
                    prox.push(createProx(pos.x, pos.y, keybinds['use'], "createdProx"));
                }
                renderProx();
                if (pos.x < 0) pos.x = 0;
                if (pos.x > window.innerWidth - 50) pos.x = window.innerWidth - 50;
                if (pos.y < 0) pos.y = 0;
                if (pos.y > window.innerHeight - 50) pos.y = window.innerHeight - 50;
                mainPlayer.style.left = pos.x + "px";
                mainPlayer.style.top = pos.y + "px";
                requestAnimationFrame(gameLoop);
            }
            gameLoop();
        </script>
    </body>
</html>